# FormalLanguagesPracticum1
Данный алгоритм поэтапно вычисляет вхождения всех подстрок данной строки из языка. Вычисление происходит при помощи стека. Далее, в итоговом языке ищется максимум длины по всем подстрокам и выводится ответ. Множество вхождений для каждого языка хранится как ```std::set<std::pair<size_t, size_t>>```, для удобства используется псевдоним ```Substrings```. Пусть n -- длина текста. Заметим, что всего подстрок у строки длины n может быть n(n + 1) / 2, поэтому размер каждого множества есть O(n<sup>2</sup>). Пустое слово является парой (0, 0).


Давайте подробно обсудим алгоритм, выполняющий каждую операцию.
1) ```Add(const Substrings& s1, const Substrings& s2)``` -- сумма языков s1 и s2. Выполняется просто как поочередное добавление всех элементов множества s2 в множество s1. Всего s2.size() операций, каждая выполняется за O(log(s1.size() + s2.size())), итоговая асимптотика O(s2.size() * log(s1.size() + s2.size())), в худшем случае O(n<sup>2</sup> log n).
2) ```Multiply(const Substrings& s1, const Substrings& s2)``` -- произведение языков s1 и s2. Выполняется следующим образом: для каждого элемента sbtr1 из множества s1 перебираются все элементы из множества s2, и проверяется, можно ли продолжить sbtr1 строкой из s2, и в случае успеха конкатенация строк добавляется в исходное множество.  Асимптотика O(s1.size() * s2.size() * (log s1.size() + log s2.size())), в худшем случае O(n<sup>4</sup> log n).
3) ```Iterate(const Substrings& s, size_t sizeOfString)``` -- итерация языка s. Выполняется как объединение степеней языка, но не бесконечное, а вплоть до n, ведь если язык непустой и мы в нем не рассматриваем пустое слово, то его (n + 1) степень не может содержать подстроку строки длины n. При этом, если на каком-то шаге мы не смогли продлить язык, то и дальше не сможем, поэтому цикл прерывается. Асимптотика в худшем случае O(n<sup>5</sup> log n).

Поговорим об итоговой асимптотике. Препроцессинг, представляющий собой просто подсчет вхождений букв a, b и c в исходном тексте, занимает O(n) времени.
Пусть L -- длина выражения в польской записи, задающего язык. Тогда, так как каждая операция в выполняется в худшем случае за O(n<sup>5</sup> log n). Получается, что в худшем случае итоговая асимптотика алгоритма есть O(L * n<sup>5</sup> log n).
